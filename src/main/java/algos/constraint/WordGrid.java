// MODIFIED by Viacheslav Mikhailov
//
// From Classic Computer Science Problems in Java
// Copyright 2020 David Kopec
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package algos.constraint;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;

public class WordGrid {
	private final char ALPHABET_LENGTH = 26;
	private final char FIRST_LETTER = 'A';
	private final int rows, columns;
	private char[][] grid;

	public WordGrid(int rows, int columns) {
		this.rows = rows;
		this.columns = columns;
		grid = new char[rows][columns];
		// initialize grid with random letters
		ThreadLocalRandom random = ThreadLocalRandom.current();
		for (int row = 0; row < rows; row++) {
			for (int column = 0; column < columns; column++) {
				char randomLetter = (char) (random.nextInt(ALPHABET_LENGTH) + FIRST_LETTER);
				grid[row][column] = randomLetter;
			}
		}
	}

	public void mark(String word, List<GridLocation> locations) {
		for (int i = 0; i < word.length(); i++) {
			GridLocation location = locations.get(i);
			grid[location.row][location.column] = word.charAt(i);
		}
	}

	// get a pretty printed version of the grid
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		for (char[] rowArray : grid) {
			sb.append(rowArray);
			sb.append(System.lineSeparator());
		}
		return sb.toString();
	}

	public List<List<GridLocation>> generateDomain(String word) {
		List<List<GridLocation>> domain = new ArrayList<>();
		int length = word.length();

		for (int row = 0; row < rows; row++) {
			for (int column = 0; column < columns; column++) {
				if (column + length <= columns) {
					// left to right
					fillRight(domain, row, column, length);
					// diagonal towards bottom right
					if (row + length <= rows) {
						fillDiagonalRight(domain, row, column, length);
					}
				}
				if (row + length <= rows) {
					// top to bottom
					fillDown(domain, row, column, length);
					// diagonal towards bottom left
					if (column - length >= 0) {
						fillDiagonalLeft(domain, row, column, length);
					}
				}
			}
		}
		return domain;
	}

	private void fillRight(List<List<GridLocation>> domain, int row, int column, int length) {
		List<GridLocation> locations = new ArrayList<>();
		for (int c = column; c < (column + length); c++) {
			locations.add(new GridLocation(row, c));
		}
		domain.add(locations);
	}

	private void fillDiagonalRight(List<List<GridLocation>> domain, int row, int column, int length) {
		List<GridLocation> locations = new ArrayList<>();
		for (int c = column, r = row; c < (column + length); c++, r++) locations.add(new GridLocation(r, c));
		domain.add(locations);
	}

	private void fillDown(List<List<GridLocation>> domain, int row, int column, int length) {
		List<GridLocation> locations = new ArrayList<>();
		for (int r = row; r < (row + length); r++) {
			locations.add(new GridLocation(r, column));
		}
		domain.add(locations);
	}

	private void fillDiagonalLeft(List<List<GridLocation>> domain, int row, int column, int length) {
		List<GridLocation> locations = new ArrayList<>();
		int c = column;
		for (int r = row; r < (row + length); r++) {
			locations.add(new GridLocation(r, c));
			c--;
		}
		domain.add(locations);
	}

	public static class GridLocation {
		public final int row, column;

		public GridLocation(int row, int column) {
			this.row = row;
			this.column = column;
		}

		// auto-generated by Eclipse
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + column;
			result = prime * result + row;
			return result;
		}

		// auto-generated by Eclipse
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null) {
				return false;
			}
			if (getClass() != obj.getClass()) {
				return false;
			}
			GridLocation other = (GridLocation) obj;
			if (column != other.column) {
				return false;
			}
			if (row != other.row) {
				return false;
			}
			return true;
		}
	}

}
